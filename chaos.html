<!--

TBD: Create the chaos mask only by parts to save memory
And: To remove the hang as the page calculates it

TBD: Generally check for duplications and build the site more sensibly, moving utils to a separate file etc.

TBD/BUG: This has far inferiour performance compared to R. Things to try:
- Check that the parity works correctly
- Check all parameters, particularly the range of the chaotic mask
- Change the order of the data (R goes channel last, Javascript channel first)


-->

<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8">
<title></title>
<link href="all.css" rel="stylesheet">
</head>

<body>

<header id="site-header"></header> <!-- This gets edited by the script -->
<script async src="header.js"></script>

<script src='chaosUtil.js'></script>

<p>This does not work very well as of now. I have an implementation in R that mostly works better, and I'm trying to spot the difference in this port.</p>
<p>In the correct version, the non-chaotic decode works about the same, while the chaotic decode is much better and doesn't produce these weird vertical colorful lines.</p>
<p>I uploaded this pretty much just for tests of the interface on my phone.</p>

<p>If you want to encode an image, upload it here and save the result.
<br>
<input type=file id="chaosInput"> 
<canvas id="chaosCanvas" width="0" height="0"></canvas>
<script src='mask.js'></script>
</p>

<p>If you want to decode a masked image, upload it here.
<br>
<input type=file id="unmaskInput"> 
<canvas id="unmaskCanvas" width="0" height="0"></canvas>

<script src='unmask.js'></script>
</p>

<p>If you want to decode a masked image, but don't believe in chaos, upload it here.
<br>
<input type=file id="badInput"> 
<canvas id="badCanvas" width="0" height="0"></canvas>

<script src='bad.js'></script>


</p>

<!--
<p>
  Notice that if you try inputting the same image multiple times, you get a different result.
  The mask overlay has a random element to it, and the decoder thus cannot recreate it exactly.
</p>
<p>
  How does this work?
  The mask comes from a time series of a Lorenz system.
  The decoder is another Lorenz system set to synchronise with the original one.
  Of course, the data it gets is a sum of the output of a Lorenz system and data from the image.
  But the system doesn't understand image data at all, so it just ignores it.
  This was inspired by work from Steven Strogatz, as explained <a href="https://www.youtube.com/watch?v=FJn9xIW5d20">here</a>.
</p>
-->

<footer id="site-footer"></footer> <!-- This gets edited by the script -->
<script async src="footer.js"></script>

</body></html>
